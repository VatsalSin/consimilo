(ns consimilo.core
  (:require [consimilo.lsh-forest :refer [new-forest
                                          add-lsh!
                                          index!]]
            [consimilo.minhash :refer [build-minhash]]
            [consimilo.minhash-util :refer [jaccard-similarity
                                            hamming-distance
                                            cosine-distance
                                            zip-similarity]]
            [consimilo.lsh-query :refer [query]]
            [consimilo.text-processing :refer [tokenize-text
                                               extract-text]])

  (:import (clojure.lang IAtom)))

;; TODO: add ability to serialize / deserialize forests

(defn add-all-to-forest
  "Adds each vector in `feature-coll` to an lsh forest and returns the forest.
  If you want to add the `feature-coll` to an existing `forest` pass the forest as the first argument.
  Each item of `feature-coll` should be a map with :id and :features entries.
  The :id is the identifier for the minhash vector that will be returned upon query of the forest.
  This id can be utilized to lookup the minhash vector in the :keys hashmap of the forest.
  The :features is a collection of strings which will be utilized to create the minhash vector
  (e.g. in the case of a document, the :features could be tokens or n-grams).

  Note: items should be loaded into the forest as few times as possible in large chunks. An expensive
  sort called after items are added to the forest to enable ~log(n) queries."
  ([feature-coll]
   (add-all-to-forest (new-forest) feature-coll))
  ([forest feature-coll]
   (dorun (pmap #(add-lsh! forest (:id %) (build-minhash (:features %))) feature-coll))
   (index! forest)
   forest))

(defn add-strings-to-forest
  "Convenience method for processing documents. Each item of feature-coll should be a map with
  :id and :features entries. The :id is the identifier for the minhash vector stored in the forest.
  The :features is a string which will be tokenized into features per the optional
  parameters. The feature vector will be minhashed and inserted into the lsh-forest.

  Optional Keyword Arguments: :forest - add to an existing forest; default: create new forest
                              :stopwords? - if true: remove stopwords; default: true

  Note: items should be loaded into the forest as few times as possible in large chunks. An expensive
  sort called after items are added to the forest to enable ~log(n) queries."

  [feature-coll & {:keys [forest stopwords?]
                   :or {forest (new-forest) stopwords? true}}]
  (add-all-to-forest forest
                     (map #(assoc % :features
                                    (tokenize-text (:features %)))
                          feature-coll)))

(defn add-files-to-forest
  "Convenience method for processing files. Files should be a collection of File objects.
  The :id used for entry into the forest will be generated from the file name. The :features will
  be generated by extracting the text from each file and tokenizing and/or shingling per the optional
  parameters. The feature vector is minhashed and inserted into the lsh-forest.

  Optional Keyword Arguments: :forest - add to an existing forest; default: create new forest
                              :stopwords? - if true: remove stopwords; default: true

  Note: items should be loaded into the forest as few times as possible in large chunks. An expensive
  sort called after items are added to the forest to enable ~log(n) queries."
  [files & {:keys [forest stopwords?]
            :or {forest (new-forest) stopwords? true}}]
  (add-strings-to-forest (map (fn [f] {:id (.getName f)
                                       :features (extract-text f)})
                              files)
                         :forest forest))

(defn query-forest
  "Finds the closest `k` vectors to vector `v` stored in the `forest`."
  [forest k v]
  (let [minhash (build-minhash v)]
    {:top-k (query forest k minhash) :query-hash minhash}))

(defn query-string
  "Convenience method for querying the forest for top-k similar strings. forest is the forest to be
  queried. string will be converted to a feature vector through tokenization / shingling per the optional
  parameters. The feature vector is minhashed and used to query the forest. K is the number of results
  (top-k most similar items).

  Optional Keyword Arguments: :stopwords? - if true: remove stopwords; default: true

  Note: for best results query the forest utilizing the same tokenization scheme used to create it"
  [forest k string & {:keys [stopwords?]
                      :or {stopwords? true}}]
  (query-forest forest
                k
                (tokenize-text string)))

(defn query-file
  "Convenience method for querying the forest for top-k similar files. Forest is the forest to be
  queried. File is converted to a feature vector through text-extraction, tokenizating / shingling
  per the optional arguments. The feature vector is minhashed and used to query the forest. k is the number
  of results (top-k most similar items).

  Optional Keyword Arguments: :stopwords? - if true: remove stopwords; default: true

  Note: for best results query the forest utilizing the same tokenization scheme used to create it"
  [forest k file & {:keys [stopwords?]
                    :or {stopwords? true}}]
  (query-string forest
                k
                (extract-text file)))

(defmulti similarity-k
  "Query forest for top-k items, return pairs: {item-key, sim-fn}. Available similarity functions are Jaccard
  similarity, cosine distance, and Hamming distance. sim-fn is defaulted to :jaccard, but can be overridden by passing
  the optional :sim-fn key and :jaccard, :cosine, or :hamming. similarity-k Dispatches based on input: string, file,
  or feature-vector."
  (fn [forest k input & {:keys [sim-fn stopwords?]
                         :or {sim-fn :jaccard stopwords? true}}]
    (cond
      (coll? input) :feature-vec
      (string? input) :string
      :else :file)))

(defmethod similarity-k :string
  [forest k string & {:keys [sim-fn stopwords?]
                      :or {sim-fn :jaccard stopwords? true}}]
  (let [return (query-string forest k string :stopwords? stopwords?)
        f (condp = sim-fn
            :jaccard jaccard-similarity
            :cosine cosine-distance
            :hamming hamming-distance)]
    (zip-similarity forest return f)))

(defmethod similarity-k :file
  [forest k file & {:keys [sim-fn stopwords?]
                    :or {sim-fn :jaccard stopwords? true}}]
  (let [return (query-file forest k file :stopwords? stopwords?)
        f (condp = sim-fn
            :jaccard jaccard-similarity
            :cosine cosine-distance
            :hamming hamming-distance)]
    (zip-similarity forest return f)))

(defmethod similarity-k :feature-vec
  [forest k feature-vector & {:keys [sim-fn]
                              :or {sim-fn :jaccard}}]
  (let [return (query-forest forest k feature-vector)
        f (condp = sim-fn
            :jaccard jaccard-similarity
            :cosine cosine-distance
            :hamming hamming-distance)]
    (zip-similarity forest return f)))
